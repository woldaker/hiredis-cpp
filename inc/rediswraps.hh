#ifndef REDISWRAPS_HH
#define REDISWRAPS_HH

#include <cstring> // strcpy() used in format_cmd_args()

#include <array>         // used in cmd_proxy()
#include <deque>         // Holds all the response strings from Redis
#include <iostream>
#include <fstream>       // used in read_file()
#include <sstream>       // used in read_file()
#include <string>
#include <type_traits>   // enable_if<>...
#include <unordered_map> // Maps Lua scripts to their hash digests.
#include <utility>       // std::forward, std::pair

#include <boost/lexical_cast.hpp>
#include <boost/optional.hpp>

extern "C" {
#include <hiredis/hiredis.h>
}

#ifndef REDISWRAPS_DEBUG
#define INLINE inline
#else
//TODO maybe #define INLINE {;}
#define INLINE 
#endif

namespace rediswraps {

namespace cmdopt { // {{{
//   Used as a bitmask for behavior in Connection::cmd()
constexpr unsigned char QUEUE   = (1 << 0);
constexpr unsigned char DISCARD = (1 << 1);
constexpr unsigned char FLUSH   = (1 << 2);
constexpr unsigned char PERSIST = (1 << 3);

constexpr unsigned char QUEUE_FLAGS = (QUEUE | DISCARD);
constexpr unsigned char FLUSH_FLAGS = (FLUSH | PERSIST);

constexpr unsigned char DEFAULTS = (QUEUE | FLUSH);

// Verify<FLAGS>() checks flag validity at compile-time
template<unsigned char Flags>
void Verify() noexcept {
  static_assert(cmdopt::QUEUE_FLAGS != (Flags & (cmdopt::QUEUE_FLAGS)),
    "Setting both CmdOpt flags (QUEUE | DISCARD) is contradictory."
  );

  static_assert(cmdopt::FLUSH_FLAGS != (Flags & cmdopt::FLUSH_FLAGS),
    "Setting both CmdOpt flags (FLUSH | PERSIST) is contradictory."
  );
}
} // namespace cmdopt }}}

namespace CONSTANTS { // {{{
constexpr char const *NIL = "(nil)";
constexpr char const *OK  = "OK";

constexpr char const *UNKNOWN_STR = "";
constexpr int         UNKNOWN_INT = -1;

// Number of chars in hash string generated by Redis when Lua
//   or other scripts are digested and stored for reuse.
constexpr size_t SCRIPT_HASH_LENGTH = 40;
} // namespace CONSTANTS }}}

namespace DEFAULT { // {{{
constexpr char const *HOST = "127.0.0.1";
constexpr int         PORT = 6379;
} // namespace DEFAULT }}}

struct Void {};


// rediswraps::utils {{{
namespace utils {
// DEBUG FUNCTIONS {{{
//TODO REMOVE THESE
#ifdef REDISWRAPS_DEBUG
auto WHEREAMI = [](std::string const &desc = "") -> void {
  std::cout << "\n-------------------------\nIn function:\n\n"
    << (!desc.empty() ? desc : __PRETTY_FUNCTION__)
  << "\n" << std::endl;
};
#else
//TODO remove this at the very least
#define WHEREAMI() 
#endif
// DEBUG FUNCTIONS }}}

template<typename Token, typename = typename std::enable_if<std::is_constructible<std::string, Token>::value>::type, typename Dummy = void>
INLINE
std::string to_string(Token const &item) {
  return item;
}

template<typename Token, typename = typename std::enable_if<!std::is_constructible<std::string, Token>::value>::type>
INLINE
std::string to_string(Token const &item) {
  std::string converted;

  if (boost::conversion::try_lexical_convert(item, converted)) {
    return converted;
  }

  //TODO remove me
  WHEREAMI();
  return "";
}

// MORE DEBUG FUNCTIONS {{{
#ifdef REDISWRAPS_DEBUG
template<typename Arg>
std::string args_to_string(Arg const &arg) {
  return utils::to_string(arg);
}

template<typename Arg, typename... Args>
std::string args_to_string(Arg const &arg, Args&&... args) {
  std::string arg_string(utils::to_string(arg));
  arg_string += ", ";
  return arg_string += args_to_string(std::forward<Args>(args)...);
}
#endif
// MORE DEBUG FUNCTIONS }}}


template<typename TargetType, typename = typename std::enable_if<std::is_default_constructible<TargetType>::value && !std::is_void<TargetType>::value>::type>
INLINE
TargetType convert(std::string const &target) {
  TargetType new_target;

#ifdef REDISWRAPS_DEBUG
  std::cout << "Converting string '" << target << "' to type '" << typeid(TargetType).name() << "'" << std::endl;
#endif

  if (boost::conversion::try_lexical_convert(target, new_target)) {
    return new_target;
  }

  //TODO remove me
  WHEREAMI();
  return TargetType();
}

template<>
INLINE
bool convert<bool>(std::string const &target) {
  return !target.empty() && (target != CONSTANTS::NIL) && (
    (target == CONSTANTS::OK) ||
    // In order to make strings literally containing "true" return true, uncomment the following:
    // (target == "true") ||
    (std::strtol(target.c_str(), nullptr, 10) != 0)
    // Case-insensitive version.  e.g. also convert "TrUe" to true:
    // || (target.length() == 4 &&
    //  (target[0] == 'T' || target[0] == 't') &&
    //  (target[1] == 'R' || target[1] == 'r') &&
    //  (target[2] == 'U' || target[2] == 'u') &&
    //  (target[3] == 'E' || target[3] == 'e')
    //)
  );
}


std::string const read_file(std::string const &filepath) {
  std::ifstream input(filepath);
  std::stringstream buffer;

  buffer << input.rdbuf();
  return buffer.str();
}

} // rediswraps::utils }}}


// class Response {{{
//   Simple wrapper around std::string that adds an error check bool
class Response {
  friend class Connection;

 // public {{{
 public:
  //TODO inline?
  Response() : success_(true) {}

  template<typename T>
  //TODO inline?
  Response(T data, bool success = true)
      : data_(utils::to_string(data)),
        success_(success)
  {}

  template<typename T>
  INLINE
  operator T() const noexcept {
    return utils::convert<T>(this->data());
  }

  // bool() -- two variants {{{
  // For L-vals
  INLINE
  operator bool() const& noexcept {
    return this->success();
  }

  // For R-vals
  INLINE
  operator bool() && noexcept {
    return this->success() && utils::convert<bool>(this->data());
  }
  // bool() - two variants }}}

  INLINE
  operator Void() const& noexcept {
    return {};
  }

//  INLINE
//  operator std::string() const noexcept {
//    return this->data();
//  }

  INLINE
  std::string const data() const noexcept {
    return this->data_;
  }
  
  INLINE
  bool const success() const noexcept {
    return this->success_;
  }
 // public }}}

 // private {{{
 private:
  std::string data_;
  bool success_;

  template<typename T>
  INLINE
  void set(T new_data) noexcept {
    this->data_ = utils::to_string(new_data);
  }

  INLINE
  void fail() noexcept {
    this->success_ = false;
  }
 // private }}}
};
// class Response }}}


class Connection { // {{{
// public interface {{{
 public:
  // constructors & destructors {{{
  Connection(std::string const &host = DEFAULT::HOST, int const port = DEFAULT::PORT, std::string const &name = "")
      : socket_(boost::none),
        host_(boost::make_optional(!host.empty(), host)),
        port_(boost::make_optional(port > 0, port)),
        name_(boost::make_optional(!name.empty(), name))
  {
    this->connect();
  }

  Connection(std::string const &socket, std::string const &name = "")
      : socket_(boost::make_optional(!socket.empty(), socket)),
        host_(boost::none),
        port_(boost::none),
        name_(boost::make_optional(!name.empty(), name))
  {
    this->connect();
  }

  ~Connection() {
    this->disconnect();
  }
  // constructors & destructors }}}

  // description() {{{
  std::string description() const {
    std::string desc("RedisWraps Connection {");
    
    desc += "\nName : "; desc += this->name();

    if (this->using_socket()) {
      desc += "\nSocket : "; desc += this->socket();
    }
    else if (this->using_host_and_port()) {
      desc += "\nHost : "; desc += this->host();
      desc += "\nPort : "; desc += utils::to_string(this->port());
    }

    desc += "\n\nQueued Responses : ";
    desc += this->all_responses();

    desc += "\n\n}";
    return desc;
  }
  // description() }}}

  // small, inline methods {{{
  INLINE
  void flush() {
    this->responses_ = {};
  }

  INLINE
  bool const has_response() const noexcept {
    return !this->responses_.empty();
  }

  INLINE
  size_t const num_responses() const {
    return this->responses_.size();
  }

  INLINE
  bool const is_connected() const noexcept {
    return !(this->context_ == nullptr || this->context_->err);
  }

  INLINE
  std::string const &name() const noexcept {
    return this->name_ ? *this->name_ : CONSTANTS::UNKNOWN_STR;
  }

  INLINE
  std::string const &socket() const noexcept {
    return this->socket_ ? *this->socket_ : CONSTANTS::UNKNOWN_STR;
  }

  INLINE
  std::string const &host() const noexcept {
    return this->host_ ? *this->host_ : CONSTANTS::UNKNOWN_STR;
  }

  INLINE
  int const port() const noexcept {
    return this->port_ ? *this->port_ : CONSTANTS::UNKNOWN_INT;
  }

//  INLINE
//  int const db() const noexcept {
//    return this->db_;
//  }

//  INLINE
//  bool const is_cluster() const noexcept {
//    return this->is_cluster_;
//  }
  // small, inline methods }}}

  // load_lua_script methods {{{
  //
  // Loads a Lua script at either a filepath or from a string into Redis with a chosen alias.
  // This script must expect its first "keycount" number of arguments to be names of Redis keys.
  //
  // For example, if foo.lua expects one key name as its first argument, then:
  //
  //   this->load_lua_script("/path/to/foo.lua", "foo", 1);
  //
  // enables the following (assuming "bar" is some key name):
  //
  //   this->cmd("foo", "bar", 4, 1.23);
  //
  bool const load_lua_script_from_string(
      std::string const &script_contents,
      std::string const &alias,
      size_t const keycount = 0,
      bool const flush_old_scripts = false
  ) {
    static bool okay_to_flush = true;

    if (flush_old_scripts) {
      if (okay_to_flush) {
        if (this->cmd("SCRIPT", "FLUSH")) {
          okay_to_flush = false;
        }
        else {
          std::cerr << "Warning: Couldn't flush old Lua scripts from Redis." << std::endl;
        }
      }
      else {
        std::cerr << "Warning: Scripts previously stored in Redis have already been flushed.  "
          "There is no need to do it again."
        << std::endl;
      }
    }

    std::string const script_hash = this->cmd("SCRIPT", "LOAD", script_contents);

//TODO is this right?
    if (
#ifdef REDISWRAPS_NOEXCEPT
      !script_hash
#else
      script_hash.empty()
#endif
    ) {
      return false;
    }

    if (script_hash.length() != CONSTANTS::SCRIPT_HASH_LENGTH) {
      std::cerr << "Error: Could not properly load Lua script '" << alias << "' into Redis: invalid hash length." << std::endl;
      return false;
    }

    this->scripts_.emplace(
      alias,
      std::pair<std::string, size_t>(
#ifdef REDISWRAPS_NOEXCEPT
        *
#endif
        script_hash,
        keycount
      )
    );

    return true;
  }

  INLINE
  bool const load_lua_script_from_file(
      std::string const &filepath,
      std::string const &alias,
      size_t const keycount = 0,
      bool const flush_old_scripts = false
  ) {
    return this->load_lua_script_from_string(utils::read_file(filepath), alias, keycount, flush_old_scripts);
  }

  // shorter alias for the filepath version:
  INLINE
  bool const load_lua_script(
    std::string const &filepath,
    std::string const &alias,
    size_t const keycount = 0,
    bool const flush_old_scripts = false
  ) {
    return this->load_lua_script_from_file(filepath, alias, keycount, flush_old_scripts);
  }
  // load_lua_script methods }}}


  // cmd() {{{
  //   Sends Redis a command.
  // The first argument is the command itself (e.g. "SETEX") and thus must be a string.
  //   All subsequent arguments will be converted to string automatically before being sent
  //   to Redis.
  //
  // The template argument is a bitmask enum for which you can select options.
  // See enum class CmdOpt above for the actual definition.
  //
  // There are really only two settings:
  // 1)  DISCARD or QUEUE any responses to this command
  // 2)  PERSIST or FLUSH any previously queued responses before issuing this command
  //
  // The default options are (QUEUE | FLUSH) to accomodate the basic command call:
  //   std::string foo = redis->cmd(..);
  //
  //   which would need to queue the response (so it can be assigned to foo)
  //   and flush any old responses (so foo receives the value it looks like it would)
  //
  // A compile-time error will be raised if either:
  //   Both DISCARD and QUEUE are set
  //   Both PERSIST and FLUSH are set
  //
  template<unsigned char opts = cmdopt::DEFAULTS, typename... Args>
  INLINE
  Connection& cmd(std::string const &base, Args&&... args) noexcept {
    cmdopt::Verify<opts>();
    
    if (opts & cmdopt::FLUSH) {
      this->flush();
    }

    if (this->scripts_.count(base)) {
      return this->cmd_proxy<opts>(
        "EVALSHA",
        this->scripts_[base].first,
        this->scripts_[base].second,
        std::forward<Args>(args)...
      );
    }

    return this->cmd_proxy<opts>(base, std::forward<Args>(args)...);
  }
  // cmd() }}}


  // response() {{{
  INLINE
  Response const response(bool const pop_response = true, bool const from_front = false) const noexcept {
    if (!this->has_response()) {
      return Response("The Redis response queue is empty.", false);
    }

    if (!pop_response) {
      return Response(from_front ? this->responses_.front() : this->responses_.back());
    }
    else if (from_front) {
      std::cerr << "WARNING: You are popping from the front of the Redis response queue.  "
        "This is not recommended.  See RedisWraps README."
      << std::endl;
    }

    Response response(from_front ? this->responses_.front() : this->responses_.back());

    if (from_front) {
      this->responses_.pop_front();
    }
    else {
      this->responses_.pop_back();
    }

    return response;
  }
  // response() }}}

  // last_response() {{{
  //   Returns the most recent Redis response.
  // Does not pop that response from the front.
  // Useful for debugging.
  //
  INLINE
  Response const last_response(bool const pop_response = false) const {
    return this->response(pop_response, true);
  }
  // last_response() }}}

  // stringification and operator<< {{{
  //   returns all responses in the queue at once, as one big \n-delimited string.
  // Useful for debugging.
  std::string const &all_responses() const {
    if (!this->has_response()) {
      return "{}";
    }

    std::string desc("{");

    for (int i = 0; auto response = this->response(); ++i) {
      desc += "\n\t[";
      desc += i;
      desc += "] => '";
      desc += response.data();
      desc += "'";
    }

    return desc += "\n}";
  }
  
  friend std::ostream& operator<< (std::ostream &os, Connection const &conn);
  // stringification and operator<< }}}

  template<typename T = std::string, typename = typename std::enable_if<!std::is_void<T>::value && !std::is_same<T,Void>::value>::type>
  INLINE
  operator T() && {
    std::cout << "NON-CONST VERSION" << std::endl;
    utils::WHEREAMI();
    return utils::convert<T>(this->response());
  }
  
  template<typename T = std::string, typename = typename std::enable_if<!std::is_void<T>::value && !std::is_same<T,Void>::value>::type>
  INLINE
  operator T() const& {
    std::cout << "CONST VERSION" << std::endl;
    utils::WHEREAMI();
    return utils::convert<T>(this->response(false));
  }

  INLINE
  operator void() const& {
   std::cout << "void VERSION" << std::endl;
  }

  INLINE
  operator Void() const& {
   std::cout << "VOID VERSION" << std::endl;
  }

  template<typename T>
  friend bool const operator ==(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator ==(T const &other, Connection const &conn);
  
  template<typename T>
  friend bool const operator !=(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator !=(T const &other, Connection const &conn);
  
  template<typename T>
  friend bool const operator <(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator <(T const &other, Connection const &conn);

  template<typename T>
  friend bool const operator <=(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator <=(T const &other, Connection const &conn);

  template<typename T>
  friend bool const operator >(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator >(T const &other, Connection const &conn);

  template<typename T>
  friend bool const operator >=(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator >=(T const &other, Connection const &conn);

  INLINE
  bool const operator ==(Connection const &other) const noexcept {
    return utils::convert<std::string>(this->response(false)) == utils::convert<std::string>(other.response(false));
  }
// public interface }}}

// private {{{
 private:
  INLINE
  bool const using_socket() const noexcept {
    return !!this->socket_;
  }

  INLINE
  bool const using_host_and_port() const noexcept {
    return (!!this->host_) && (!!this->port_);
  }

  // dis/re/connect() {{{
  void connect() {
    if (!this->is_connected()) {
      // sockets are fastest, try that first
      if (this->using_socket()) {
        this->context_ = redisConnectUnix(this->socket().c_str());
      }
      else if (this->using_host_and_port()) {
        this->context_ = redisConnect(this->host().c_str(), this->port());
      }

      if (!this->is_connected()) {
        throw std::runtime_error(
          this->description() +
            (this->context_ == nullptr ?
              "Unknown error connecting to Redis" :
              this->context_->errstr
            )
        );
      }

      if (this->name_) {
        this->cmd("CLIENT", "SETNAME", this->name());
      }
    }
  }

  INLINE
  void disconnect() noexcept {
    if (this->is_connected()) {
      redisFree(this->context_);
    }

    this->context_ = nullptr;
  }

  INLINE
  void reconnect() {
    this->disconnect();
    this->connect();
  }
  // dis/connect() }}}
  
  // parse_reply() {{{
  template<unsigned char opts/* = cmdopt::DEFAULT*/>
  Response parse_reply(redisReply *&reply, bool const recursion = false) {
    Response response;
    
    // There is a corner case where we never want to stash the response:
    //   when reply->type is REDIS_REPLY_ARRAY
    bool is_array_reply = false;

    if (reply == nullptr || this->context_ == nullptr || this->context_->err) {
      response.fail();

      if (reply == nullptr) {
        response.set("Redis reply is null");
      }
      else {
        if (this->context_ == nullptr) {
          response.set("Not connected to Redis");
        }
        else {
          response.set(this->context_->errstr);
        }

        this->reconnect();
      }
    }
    else {
      switch(reply->type) {
      case REDIS_REPLY_ERROR:
        response.fail();
        break;
      case REDIS_REPLY_STATUS:
      case REDIS_REPLY_STRING:
        response.set(reply->str);
        break;
      case REDIS_REPLY_INTEGER:
        response.set(reply->integer);
        break;
      case REDIS_REPLY_NIL:
        response.set(CONSTANTS::NIL);
        break;
      case REDIS_REPLY_ARRAY:
        // Do not queue THIS reply... which is just to start the array unrolling and
        //   carries no actual reply data with it.
        // Recursive calls in the following for loop will not enter this section (unless
        //   they too are arrays...) and will not be affected
        is_array_reply = true;

        for (size_t i = 0; i < reply->elements; ++i) {
          if (!this->parse_reply<opts>(reply->element[i], true)) {
            // if there is an error remove all the successful responses that were pushed
            //  onto the response queue before the error occurred.
            while (i-- > 0) {
              this->responses_.pop_back();
            }
            break;
          }
        }
        break;
      default:
        response.fail();
      }
    }

    if (!is_array_reply && (opts & cmdopt::QUEUE)) {
      this->responses_.emplace_front(response.data());
    }

    if (!recursion) {
      freeReplyObject(this->reply_);
    }

    return response;
  }
  // parse_reply() }}}

  // format_cmd_args() {{{
  template<int argc>
  INLINE
  void format_cmd_args(
    std::array<char*, argc> &&arg_strings,
    int const args_index
  ) {}

  template<int argc, typename Arg, typename... Args>
  void format_cmd_args(
    std::array<char*, argc> &&arg_strings,
    int const args_index,
    Arg const &arg,
    Args&&... args
  ) {
    this->format_cmd_args<argc>(
      std::forward<std::array<char*, argc>>(arg_strings),
      (args_index + 1),
      std::forward<Args>(args)...
    );

    std::string const temp(utils::to_string(arg));

    arg_strings[args_index] = new char[temp.size() + 1];
    strcpy(arg_strings[args_index], temp.c_str());
  }
  // format_cmd_args() }}}

  // cmd_proxy() {{{
  template<unsigned char opts, typename... Args>
  Connection& cmd_proxy(Args&&... args) {
    constexpr int argc = sizeof...(args);

    std::array<char*, argc> arg_strings;

    this->format_cmd_args<argc>(
      std::forward<std::array<char*, argc>>(arg_strings),
      0,
      std::forward<Args>(args)...
    );

    // if it fails maybe it disconnected?... try once to reconnect quickly before giving up
    bool reconnection_attempted = false;
    do {
      this->reply_ = reinterpret_cast<redisReply*>(
        redisCommandArgv(this->context_, argc, const_cast<char const**>(arg_strings.data()), nullptr)
      );

      if (this->reply_ != nullptr) {
        break;
      }

      if (reconnection_attempted) {
        if (opts & cmdopt::QUEUE) {
          this->responses_.emplace_back(
            this->context_->err ?
              this->context_->errstr :
              "Redis reply is null and reconnection failed.",
            false
          );
        }

        return *this;
      }

      this->reconnect();
      reconnection_attempted = true;
    }
    while (this->reply_ == nullptr);
    
    this->parse_reply<opts>(this->reply_);

    for (int i = 0; i < argc; ++i) {
      delete[] arg_strings[i];
    }

    return *this;
  }
  // cmd_proxy() }}}

  // member variables {{{
  boost::optional<std::string> socket_;
  boost::optional<std::string> host_;
  boost::optional<int>         port_;
  boost::optional<std::string> const name_;

/*
  bool is_cluster_;
  int db_;
*/

  redisContext *context_ = nullptr;
  redisReply   *reply_   = nullptr;

  mutable std::deque<std::string> responses_ = {};

  // scripts_ maps the name of the lua script to the sha hash and the # of
  //   keys the script expects
  std::unordered_map<std::string, std::pair<std::string, size_t>> scripts_ = {};
  // member variables }}}
// private }}}
};
// class Connection }}}

INLINE std::ostream& operator<< (std::ostream &os, Connection const &conn) {
  return os << conn.description();
}

// operator ==
template<typename T>
INLINE
bool const operator ==(Connection const &conn, T const &other) {
  auto response = conn.response(false);
  return response && (utils::convert<T>(response.data()) == other);
}

template<typename T>
INLINE
bool const operator ==(T const &other, Connection const &conn) {
  auto response = conn.response(false);
  return response && (other == utils::convert<T>(response.data()));
}

// operator <
template<typename T>
INLINE
bool const operator <(Connection const &conn, T const &other) {
  auto response = conn.response(false);
  return response && (utils::convert<T>(response.data()) < other);
}

template<typename T>
INLINE
bool const operator <(T const &other, Connection const &conn) {
  auto response = conn.response(false);
  return response && (other < utils::convert<T>(response.data()));
}

// operator !=
template<typename T>
INLINE
bool const operator !=(Connection const &conn, T const &other) {
  return !(conn == other);
}

template<typename T>
INLINE
bool const operator !=(T const &other, Connection const &conn) {
  return !(other == conn);
}

// opeartor >
template<typename T>
INLINE
bool const operator >(Connection const &conn, T const &other) {
  return !(conn < other || conn == other);
}

template<typename T>
INLINE
bool const operator >(T const &other, Connection const &conn) {
  return !(other < conn || other == conn);
}

// operator <=
template<typename T>
INLINE
bool const operator <=(Connection const &conn, T const &other) {
  return !(conn > other);
}

template<typename T>
INLINE
bool const operator <=(T const &other, Connection const &conn) {
  return !(other > conn);
}

// operator >=
template<typename T>
INLINE
bool const operator >=(Connection const &conn, T const &other) {
  return !(conn < other);
}

template<typename T>
INLINE
bool const operator >=(T const &other, Connection const &conn) {
  return !(other < conn);
}

} // namespace rediswraps

//TODO get rid of this macro
#undef INLINE

#endif

