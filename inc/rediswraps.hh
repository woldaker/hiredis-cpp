#ifndef REDISWRAPS_HH
#define REDISWRAPS_HH

#include <cstring> // strcpy() used in format_cmd_args()

#include <array>         // used in cmd_proxy()
#include <deque>         // Holds all the response strings from Redis
#include <iostream>
#include <fstream>       // used in read_file()
#include <sstream>       // used in read_file()
#include <string>
#include <type_traits>   // enable_if<>...
#include <unordered_map> // Maps Lua scripts to their hash digests.
#include <utility>       // std::forward, std::pair

#include <boost/lexical_cast.hpp>
#include <boost/optional.hpp>

extern "C" {
#include <hiredis/hiredis.h>
}

namespace rediswraps {
// CmdOpt {{{
//   Used as a bitmask for behavior in Connection::cmd()
namespace cmdopt {
constexpr unsigned char QUEUE   = (1 << 0);
constexpr unsigned char DISCARD = (1 << 1);
constexpr unsigned char FLUSH   = (1 << 2);
constexpr unsigned char PERSIST = (1 << 3);

constexpr unsigned char QUEUE_FLAGS = (QUEUE | DISCARD);
constexpr unsigned char FLUSH_FLAGS = (FLUSH | PERSIST);

constexpr unsigned char DEFAULTS = (QUEUE | FLUSH);
} // namespace cmdopt

template<unsigned char Flags>
struct CmdOpts {
  static void verify() noexcept {
    static_assert(cmdopt::QUEUE_FLAGS != (Flags & (cmdopt::QUEUE_FLAGS)),
      "Setting both CmdOpt flags (QUEUE | DISCARD) is contradictory."
    );

    static_assert(cmdopt::FLUSH_FLAGS != (Flags & cmdopt::FLUSH_FLAGS),
      "Setting both CmdOpt flags (FLUSH | PERSIST) is contradictory."
    );
  }
};
// CmdOpt }}}

namespace DEFAULT {
  constexpr char const *HOST = "127.0.0.1";
  constexpr int         PORT = 6379;
}

constexpr char const *NIL = "(nil)";
constexpr char const *OK  = "OK";

// Number of chars in hash string generated by Redis when Lua
//   or other scripts are digested and stored for reuse.
constexpr size_t SCRIPT_HASH_LENGTH = 40;

// rediswraps::utils {{{
namespace utils {
template<typename Token, typename = typename std::enable_if<std::is_constructible<std::string, Token>::value>::type, typename Dummy = void>
#ifndef REDISWRAPS_DEBUG
inline
#endif
std::string to_string(Token const &item) {
  return item;
}

template<typename Token, typename = typename std::enable_if<!std::is_constructible<std::string, Token>::value>::type>
#ifndef REDISWRAPS_DEBUG
inline
#endif
std::string to_string(Token const &item) {
  std::string converted;

  if (boost::conversion::try_lexical_convert(item, converted)) {
    return converted;
  }

  std::cerr << "Conversion ERROR:\n" << __PRETTY_FUNCTION__ << std::endl;
  return "";
}


template<typename TargetType, typename = typename std::enable_if<std::is_default_constructible<TargetType>::value && !std::is_void<TargetType>::value>::type>
#ifndef REDISWRAPS_DEBUG
inline
#endif
TargetType convert(std::string const &target) {
  TargetType new_target;

#ifdef REDISWRAPS_DEBUG
  std::cout << "Converting string '" << target << "' to type '" << typeid(TargetType).name() << "'" << std::endl;
#endif

  return boost::conversion::try_lexical_convert(target, new_target) ?
    new_target :
    (std::cerr << "Conversion ERROR:\n" << __PRETTY_FUNCTION__ << std::endl, TargetType());
}

template<>
#ifndef REDISWRAPS_DEBUG
inline
#endif
bool convert<bool>(std::string const &target) {
  return !target.empty() && (target != NIL) && (
    (target == OK) ||
    // In order to make strings literally containing "true" return true, uncomment the following:
    // (target == "true") ||
    (std::strtol(target.c_str(), nullptr, 10) != 0)
    // Case-insensitive version.  e.g. also convert "TrUe" to true:
    // || (target.length() == 4 &&
    //  (target[0] == 'T' || target[0] == 't') &&
    //  (target[1] == 'R' || target[1] == 'r') &&
    //  (target[2] == 'U' || target[2] == 'u') &&
    //  (target[3] == 'E' || target[3] == 'e')
    //)
  );
}


std::string const read_file(std::string const &filepath) {
  std::ifstream input(filepath);
  std::stringstream buffer;

  buffer << input.rdbuf();
  return buffer.str();
}
} // rediswraps::utils }}}


// DEBUG FUNCTIONS {{{
#ifdef REDISWRAPS_DEBUG
template<typename Arg>
inline std::string args_to_string(Arg const &arg) {
  return utils::to_string(arg);
}

template<typename Arg, typename... Args>
inline std::string args_to_string(Arg const &arg, Args&&... args) {
  std::string arg_string(utils::to_string(arg));
  arg_string += ", ";
  return arg_string += args_to_string(std::forward<Args>(args)...);
}

auto WHEREAMI = [](std::string const &desc = "") -> void {
  std::cout << "\n-------------------------\nIn function:\n\n"
    << (!desc.empty() ? desc : __PRETTY_FUNCTION__)
  << "\n" << std::endl;
};
#endif
// DEBUG FUNCTIONS }}}

// class Response {{{
//   Simple wrapper around std::string that adds an error check bool
class Response {
 public:
  Response() : success_(true) {}

  template<typename T>
  Response(T data, bool success = true)
      : data_(utils::to_string(data)),
        success_(success)
  {}

  template<typename T>
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  operator T() const noexcept {
    return utils::convert<T>(this->data());
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  operator bool() const& noexcept {
    return this->success();
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  operator bool() && noexcept {
    return this->success_ && utils::convert<bool>(this->data());
  }

/*
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  operator std::string() const noexcept {
    return this->data();
  }
*/
  template<typename T>
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  void set(T new_data) noexcept {
    this->data_ = utils::to_string(new_data);
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  void fail() noexcept {
    this->success_ = false;
  }
  
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  std::string const data() const noexcept {
    return this->data_;
  }
  
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  bool const success() const noexcept {
    return this->success_;
  }
  
 private:
  std::string data_;
  bool success_;
};
// class Response }}}



class Connection {
// public interface {{{
 public:
  // constructors & destructors {{{
  Connection(std::string const &host = DEFAULT::HOST, int const port = DEFAULT::PORT, std::string const &name = "")
      : socket_(boost::none),
        host_(boost::make_optional(!host.empty(), host)),
        port_(boost::make_optional(port > 0, port)),
        name_(boost::make_optional(!name.empty(), name))
  {
    this->connect();
  }

  Connection(std::string const &socket, std::string const &name = "")
      : socket_(boost::make_optional(!socket.empty(), socket)),
        host_(boost::none),
        port_(boost::none),
        name_(boost::make_optional(!name.empty(), name))
  {
    this->connect();
  }

  ~Connection() {
    this->disconnect();
  }
  // constructors & destructors }}}

  // description() {{{
  std::string description() const {
    std::string desc("RedisWraps Connection {");
    
    if (auto name = this->name()) {
      desc += "\nName : "; desc += *name;
    }

    if (this->using_socket()) {
      if (auto socket = this->socket()) {
        desc += "\nSocket : "; desc += *socket;
      }
    }
    else {
      if (auto host = this->host()) {
        desc += "\nHost : "; desc += *host;
      }

      if (auto port = this->port()) {
        desc += "\nPort : "; desc += utils::to_string(*port);
      }
    }

    desc += "\n\nQueued Responses : ";
    desc += this->all_responses();

    desc += "\n\n}";
    return desc;
  }
  // description() }}}

  // small, inline methods {{{
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  void flush() {
    this->responses_ = {};
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  bool const has_response() const noexcept {
    return !this->responses_.empty();
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  size_t const num_responses() const {
    return this->responses_.size();
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  bool const is_connected() const noexcept {
    return !(this->context_ == nullptr || this->context_->err);
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  boost::optional<std::string> const &name() const noexcept {
    return this->name_;
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  bool const using_socket() const noexcept {
    return !!this->socket_;
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  bool const using_host_and_port() const noexcept {
    return !!this->host_ && !!this->port_;
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  boost::optional<std::string> const &socket() const noexcept {
    return this->socket_;
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  boost::optional<std::string> const &host() const noexcept {
    return this->host_;
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  boost::optional<int> const &port() const noexcept {
    return this->port_;
  }

/*
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  int const db() const noexcept {
    return this->db_;
  }
*/
/*
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  bool const is_cluster() const noexcept {
    return this->is_cluster_;
  }
*/
  // small, inline methods }}}


  // load_lua_script methods {{{
  //
  // Loads a Lua script at either a filepath or from a string into Redis with a chosen alias.
  // This script must expect its first "keycount" number of arguments to be names of Redis keys.
  //
  // For example, if foo.lua expects one key name as its first argument, then:
  //
  //   this->load_lua_script("/path/to/foo.lua", "foo", 1);
  //
  // enables the following (assuming "bar" is some key name):
  //
  //   this->cmd("foo", "bar", 4, 1.23);
  //
  bool const load_lua_script_from_string(
      std::string const &script_contents,
      std::string const &alias,
      size_t const keycount = 0,
      bool const flush_old_scripts = false
  ) {
    static bool okay_to_flush = true;

    if (flush_old_scripts) {
      if (okay_to_flush) {
        if (this->cmd("SCRIPT", "FLUSH")) {
          okay_to_flush = false;
        }
        else {
          std::cerr << "Warning: Couldn't flush old Lua scripts from Redis." << std::endl;
        }
      }
      else {
        std::cerr << "Warning: Scripts previously stored in Redis have already been flushed.  "
          "There is no need to do it again."
        << std::endl;
      }
    }

    std::string const script_hash = this->cmd("SCRIPT", "LOAD", script_contents);
#ifdef REDISWRAPS_NOEXCEPT
    if (!script_hash) {
      return false;
    }

    if (script_hash->length() != SCRIPT_HASH_LENGTH) {
#else
    if (script_hash.length() != SCRIPT_HASH_LENGTH) {
#endif
      std::cerr << "Error: Could not properly load Lua script '" << alias << "' into Redis: invalid hash length." << std::endl;
      return false;
    }

    this->scripts_.emplace(
      alias,
      std::pair<std::string, size_t>(
#ifdef REDISWRAPS_NOEXCEPT
        *script_hash,
#else
        script_hash,
#endif
        keycount
      )
    );

    return true;
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  bool const load_lua_script_from_file(
      std::string const &filepath,
      std::string const &alias,
      size_t const keycount = 0,
      bool const flush_old_scripts = false
  ) {
    return this->load_lua_script_from_string(utils::read_file(filepath), alias, keycount, flush_old_scripts);
  }

  // shorter alias for the filepath version:
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  bool const load_lua_script(
    std::string const &filepath,
    std::string const &alias,
    size_t const keycount = 0,
    bool const flush_old_scripts = false
  ) {
    return this->load_lua_script_from_file(filepath, alias, keycount, flush_old_scripts);
  }
  // load_lua_script methods }}}


  // cmd() {{{
  //   Sends Redis a command.
  // The first argument is the command itself (e.g. "SETEX") and thus must be a string.
  //   All subsequent arguments will be converted to string automatically before being sent
  //   to Redis.
  //
  // The template argument is a bitmask enum for which you can select options.
  // See enum class CmdOpt above for the actual definition.
  //
  // There are really only two settings:
  // 1)  DISCARD or QUEUE any responses to this command
  // 2)  PERSIST or FLUSH any previously queued responses before issuing this command
  //
  // The default options are (QUEUE | FLUSH) to accomodate the basic command call:
  //   std::string foo = redis->cmd(..);
  //
  //   which would need to queue the response (so it can be assigned to foo)
  //   and flush any old responses (so foo receives the value it looks like it would)
  //
  // A compile-time error will be raised if either:
  //   Both DISCARD and QUEUE are set
  //   Both PERSIST and FLUSH are set
  //
  template<unsigned char opts = cmdopt::DEFAULTS, typename... Args>
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  Connection& cmd(std::string const &base, Args&&... args) noexcept {
    CmdOpts<opts>::verify();
    
    if (opts & cmdopt::FLUSH) {
      this->flush();
    }

    if (this->scripts_.count(base)) {
      return this->cmd_proxy<opts>(
        "EVALSHA",
        this->scripts_[base].first,
        this->scripts_[base].second,
        std::forward<Args>(args)...
      );
    }

    return this->cmd_proxy<opts>(base, std::forward<Args>(args)...);
  }
  // cmd() }}}


  // response() {{{
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  Response const response(bool const pop_response = true, bool const from_front = false) const noexcept {
    if (!this->has_response()) {
      return Response("The Redis response queue is empty.", false);
    }

    if (!pop_response) {
      return Response(from_front ? this->responses_.front() : this->responses_.back());
    }
    else if (from_front) {
      std::cerr << "WARNING: You are popping from the front of the Redis response queue.  "
        "This is not recommended.  See RedisWraps README."
      << std::endl;
    }

    Response response(from_front ? this->responses_.front() : this->responses_.back());

    if (from_front) {
      this->responses_.pop_front();
    }
    else {
      this->responses_.pop_back();
    }

    return response;
  }
  // response() }}}

  // last_response() {{{
  //   Returns the most recent Redis response.
  // Does not pop that response from the front.
  // Useful for debugging.
  //
#ifdef REDISWRAPS_DEBUG
  Response const last_response(bool const pop_response = false) noexcept {
    return this->response(pop_response, true);
  }
#else
  inline
  Response const last_response() noexcept {
    return this->response(false, true);
  }
#endif
  // last_response() }}}

  // all_responses() {{{
  //   returns all responses in the queue at once, as one big \n-delimited string.
  // Useful for debugging.
  std::string const &all_responses() const {
    if (!this->has_response()) {
      return "{}";
    }

    std::string desc("{");

    for (int i = 0; auto response = this->response(); ++i) {
      desc += "\n\t[";
      desc += i;
      desc += "] => '";
      desc += response.data();
      desc += "'";
    }

    return desc += "\n}";
  }
  // all_responses() }}}

  void print_responses() const {
    std::cout << this->all_responses() << std::endl;
  }

  template<typename T>
#ifdef REDISWRAPS_DEBUG
  inline
#endif
  operator T() {
    return utils::convert<T>(this->response());
  }
  
  template<typename T>
#ifdef REDISWRAPS_DEBUG
  inline
#endif
  operator T() const {
    return utils::convert<T>(this->response(false));
  }

  template<typename T>
  friend bool const operator ==(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator ==(T const &other, Connection const &conn);
  
  template<typename T>
  friend bool const operator !=(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator !=(T const &other, Connection const &conn);
  
  template<typename T>
  friend bool const operator <(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator <(T const &other, Connection const &conn);

  template<typename T>
  friend bool const operator <=(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator <=(T const &other, Connection const &conn);

  template<typename T>
  friend bool const operator >(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator >(T const &other, Connection const &conn);

  template<typename T>
  friend bool const operator >=(Connection const &conn, T const &other);

  template<typename T>
  friend bool const operator >=(T const &other, Connection const &conn);

#ifdef REDISWRAPS_DEBUG
  inline
#endif
  bool const operator ==(Connection const &other) const noexcept {
    return utils::convert<std::string>(this->response(false)) == utils::convert<std::string>(other.response(false));
  }
// public interface }}}


// private {{{
 private:
  // dis/re/connect() {{{
  void connect() {
    if (!this->is_connected()) {
      // sockets are fastest, try that first
      if (this->using_socket()) {
        this->context_ = redisConnectUnix(this->socket()->c_str());
      }
      else if (this->using_host_and_port()) {
        this->context_ = redisConnect(this->host()->c_str(), *this->port());
      }

      if (!this->is_connected()) {
        throw std::runtime_error(
          this->description() +
            (this->context_ == nullptr ?
              "Unknown error connecting to Redis" :
              this->context_->errstr
            )
        );
      }

      if (this->name() && !this->name()->empty()) {
        this->cmd("CLIENT", "SETNAME", *this->name());
      }
    }
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  void disconnect() noexcept {
    if (this->is_connected()) {
      redisFree(this->context_);
    }

    this->context_ = nullptr;
  }

#ifndef REDISWRAPS_DEBUG
  inline
#endif
  void reconnect() {
    this->disconnect();
    this->connect();
  }
  // dis/connect() }}}
  
  // parse_reply() {{{
  template<unsigned char opts/* = cmdopt::DEFAULT*/>
  Response parse_reply(redisReply *&reply, bool const recursion = false) {
    Response response;
    
    // There is a corner case where we never want to stash the response:
    //   when reply->type is REDIS_REPLY_ARRAY
    bool is_array_reply = false;

    if (reply == nullptr || this->context_ == nullptr || this->context_->err) {
      response.fail();

      if (reply == nullptr) {
        response.set("Redis reply is null");
      }
      else {
        if (this->context_ == nullptr) {
          response.set("Not connected to Redis");
        }
        else {
          response.set(this->context_->errstr);
        }

        this->reconnect();
      }
    }
    else {
      switch(reply->type) {
      case REDIS_REPLY_ERROR:
        response.fail();
        break;
      case REDIS_REPLY_STATUS:
      case REDIS_REPLY_STRING:
        response.set(reply->str);
        break;
      case REDIS_REPLY_INTEGER:
        response.set(reply->integer);
        break;
      case REDIS_REPLY_NIL:
        response.set(NIL);
        break;
      case REDIS_REPLY_ARRAY:
        // Do not queue THIS reply... which is just to start the array unrolling and
        //   carries no actual reply data with it.
        // Recursive calls in the following for loop will not enter this section (unless
        //   they too are arrays...) and will not be affected
        is_array_reply = true;

        for (size_t i = 0; i < reply->elements; ++i) {
          if (!this->parse_reply<opts>(reply->element[i], true)) {
            // if there is an error remove all the successful responses that were pushed
            //  onto the response queue before the error occurred.
            while (i-- > 0) {
              this->responses_.pop_back();
            }
            break;
          }
        }
        break;
      default:
        response.fail();
      }
    }

    if (!is_array_reply && (opts & cmdopt::QUEUE)) {
      this->responses_.emplace_front(response.data());
    }

    if (!recursion) {
      freeReplyObject(this->reply_);
    }

    return response;
  }
  // parse_reply() }}}

  // format_cmd_args() {{{
  template<int argc>
#ifndef REDISWRAPS_DEBUG
  inline
#endif
  void format_cmd_args(
    std::array<char*, argc> &&arg_strings,
    int const args_index
  ) {}

  template<int argc, typename Arg, typename... Args>
  void format_cmd_args(
    std::array<char*, argc> &&arg_strings,
    int const args_index,
    Arg const &arg,
    Args&&... args
  ) {
    this->format_cmd_args<argc>(
      std::forward<std::array<char*, argc>>(arg_strings),
      (args_index + 1),
      std::forward<Args>(args)...
    );

    std::string const temp(utils::to_string(arg));

    arg_strings[args_index] = new char[temp.size() + 1];
    strcpy(arg_strings[args_index], temp.c_str());
  }
  // format_cmd_args() }}}

  // cmd_proxy() {{{
  template<unsigned char opts, typename... Args>
  Connection& cmd_proxy(Args&&... args) {
    constexpr int argc = sizeof...(args);

    std::array<char*, argc> arg_strings;

    this->format_cmd_args<argc>(
      std::forward<std::array<char*, argc>>(arg_strings),
      0,
      std::forward<Args>(args)...
    );

    // if it fails maybe it disconnected?... try once to reconnect quickly before giving up
    bool reconnection_attempted = false;
    do {
      this->reply_ = reinterpret_cast<redisReply*>(
        redisCommandArgv(this->context_, argc, const_cast<char const**>(arg_strings.data()), nullptr)
      );

      if (this->reply_ != nullptr) {
        break;
      }

      if (reconnection_attempted) {
        if (opts & cmdopt::QUEUE) {
          this->responses_.emplace_back(
            this->context_->err ?
              this->context_->errstr :
              "Redis reply is null and reconnection failed.",
            false
          );
        }

        return *this;
      }

      this->reconnect();
      reconnection_attempted = true;
    }
    while (this->reply_ == nullptr);
    
    this->parse_reply<opts>(this->reply_);

    for (int i = 0; i < argc; ++i) {
      delete[] arg_strings[i];
    }

    return *this;
  }
  // cmd_proxy() }}}

  // member variables {{{
  boost::optional<std::string> socket_;
  boost::optional<std::string> host_;
  boost::optional<int>         port_;
  boost::optional<std::string> const name_;

/*
  bool is_cluster_;
  int db_;
*/

  redisContext *context_ = nullptr;
  redisReply   *reply_   = nullptr;

  mutable std::deque<std::string> responses_ = {};

  // scripts_ maps the name of the lua script to the sha hash and the # of
  //   keys the script expects
  std::unordered_map<std::string, std::pair<std::string, size_t>> scripts_ = {};
  // member variables }}}
// private }}}
};

// operator ==
template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator ==(Connection const &conn, T const &other) {
  auto response = conn.response(false);
  return response && (utils::convert<T>(response.data()) == other);
}

template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator ==(T const &other, Connection const &conn) {
  auto response = conn.response(false);
  return response && (other == utils::convert<T>(response.data()));
}

// operator <
template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator <(Connection const &conn, T const &other) {
  auto response = conn.response(false);
  return response && (utils::convert<T>(response.data()) < other);
}

template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator <(T const &other, Connection const &conn) {
  auto response = conn.response(false);
  return response && (other < utils::convert<T>(response.data()));
}

// operator !=
template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator !=(Connection const &conn, T const &other) {
  return !(conn == other);
}

template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator !=(T const &other, Connection const &conn) {
  return !(other == conn);
}

// opeartor >
template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator >(Connection const &conn, T const &other) {
  return !(conn < other || conn == other);
}

template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator >(T const &other, Connection const &conn) {
  return !(other < conn || other == conn);
}

// operator <=
template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator <=(Connection const &conn, T const &other) {
  return !(conn > other);
}

template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator <=(T const &other, Connection const &conn) {
  return !(other > conn);
}

// operator >=
template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator >=(Connection const &conn, T const &other) {
  return !(conn < other);
}

template<typename T>
#ifdef REDISWRAPS_DEBUG
inline
#endif
bool const operator >=(T const &other, Connection const &conn) {
  return !(other < conn);
}

} // namespace rediswraps

//using rediswraps::Stash;
//using rediswraps::Void;

#endif

