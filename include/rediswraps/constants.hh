#ifndef REDISWRAPS_CONSTANTS_HH
#define REDISWRAPS_CONSTANTS_HH

#include <type_traits>


namespace rediswraps {
namespace constants {

constexpr char const *kNil = "(nil)";
constexpr char const *kOk  = "OK";

constexpr char const *kUnknownStr = "";
constexpr int         kUnknownInt = -1;

// Number of chars in hash string generated by Redis when Lua
//   or other scripts are digested and stored for reuse.
constexpr size_t kScriptHashLength = 40;

constexpr char const *kDefaultHost = "127.0.0.1";
constexpr int         kDefaultPort = 6379;
} // namespace constants


namespace cmd {
using FlagEnum = uint8_t;

// Used as a bitmask for behavior in Connection::Cmd()
enum class Flag : FlagEnum {
  kDefaultAlias = 0x0,

  // Flush previous responses or keep them
  kFlush   = 0x1,
  kPersist = 0x2,
  // Queue response or discard/ignore it
  kQueue   = 0x4,
  kDiscard = 0x8,

  // PREDEFINED COMBINATIONS:
  // kDefault = 0x5
  // Flush old responses and queue these ones.
  //
  // For the most basic commands, this should be fine:
  //   Cmd("set", "foo", 123);
  //   int foo = Cmd("get", "foo");
  //
  kDefault = (kFlush | kQueue),

  // kSaved = 0x6
  // Keep old responses and also queue these ones.
  //
  // Useful for situations such as this:
  //   Cmd("lpush", "my_list", "foobat", "foobas", "foobar");
  //   Cmd("lrange", "my_list", 0, -1);
  //   while (Cmd<kSaved>("rpop", "my_list") != "foobar") {...}
  //
  kSaved = (kPersist | kQueue),

  // kClear = 0x9
  // Flush old responses, also ignore this one.
  //
  // Perhaps useful for commands that need a fresh queue before and afterward,
  //   or maybe you just don't care... or maybe initializing certain keys whose
  //   responses can be safely ignored for some reason?...
  // Maybe for stuff like:
  //
  //   Cmd<kClear>("select", 2);
  //
  // NOTE: Should be zero responses afterward.
  //   Subsequent attempts to fetch a response will be in error.
  //   response() -> returns boost::none w/ error msg attached
  //
  kClear = (kFlush | kDiscard),

  // kVoid = 0xA
  // Keep old responses but discard these ones.
  //
  // Useful for commands that would disrupt the state of the response queue:
  //   Cmd("lpush", "my_list", Cmd("rpop", "other_list"));
  //   Cmd("lrange", "my_list", 0, -1);
  //     You simply cannot wait and MUST delete other_list here:
  //   Cmd<kVoid>("del", "other_list")
  //   
  //   while(auto queued_response = response()) {
  //     // do something with queued_response...
  //   }
  //
  kVoid = (kPersist | kDiscard),

  // ILLEGAL OPTIONS: contradictory
  kIllegalFlushOpts = (kFlush | kPersist), // 0x3
  kIllegalQueueOpts = (kQueue | kDiscard), // 0xC
  // for completeness:
  kIllegalFlushOpts2 = (kIllegalFlushOpts | kQueue),   // 0x7
  kIllegalFlushOpts3 = (kIllegalFlushOpts | kDiscard), // 0xB
  kIllegalQueueOpts2 = (kIllegalQueueOpts | kFlush),   // 0xD
  kIllegalQueueOpts3 = (kIllegalQueueOpts | kPersist), // 0xE
  kIllegalOptsAll    = (kIllegalFlushOpts | kIllegalQueueOpts) // 0xF
};

// For readability:
constexpr Flag DEFAULT = Flag::kDefault;
constexpr Flag SAVED   = Flag::kSaved;
constexpr Flag CLEAR   = Flag::kClear;
constexpr Flag VOID    = Flag::kVoid;

template<Flag T> struct FlagsAreLegal
  : std::integral_constant<bool, 
      static_cast<FlagEnum>(T) != (
        static_cast<FlagEnum>(T) &
        static_cast<FlagEnum>(Flag::kIllegalFlushOpts)
      ) &&
      static_cast<FlagEnum>(T) != (
        static_cast<FlagEnum>(T) &
        static_cast<FlagEnum>(Flag::kIllegalQueueOpts)
      )
    >
{};

template<Flag T> struct FlagsFlushResponses
  : std::integral_constant<bool, 
      !!(static_cast<FlagEnum>(T) & static_cast<FlagEnum>(Flag::kFlush))
    >
{};

template<Flag T> struct FlagsQueueResponses
  : std::integral_constant<bool, 
      !!(static_cast<FlagEnum>(T) & static_cast<FlagEnum>(Flag::kQueue))
    >
{};

} // namespace cmd
} // namespace rediswraps

#endif

